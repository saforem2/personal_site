


```{=html}
<script type="module">
const lastFmConfig = {
  user: 'saforem2',
  apiKey: '1dbc15037c1fe71ce06acbb3f73adc75',
  endpoint: 'https://ws.audioscrobbler.com/2.0/',
  refreshInterval: 60000,
  requestTimeout: 8000,
};

const buildUrl = () => {
  const params = new URLSearchParams({
    method: 'user.getrecenttracks',
    user: lastFmConfig.user,
    api_key: lastFmConfig.apiKey,
    format: 'json',
    limit: '1',
  });
  return `${lastFmConfig.endpoint}?${params.toString()}`;
};

const prefersReducedData = () => {
  if (window.matchMedia?.('(prefers-reduced-data: reduce)').matches) {
    return true;
  }
  const connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
  return Boolean(connection?.saveData);
};

const init = () => {
  const root = document.querySelector('[data-lastfm-root]');
  if (!root) {
    return;
  }

  const elements = {
    art: root.querySelector('[data-track-art]'),
    title: root.querySelector('[data-track-title]'),
    artist: root.querySelector('[data-track-artist]'),
  };

  const hostDetails = root.closest('details');

  const setFallback = (options = {}) => {
    const { reason } = options;
    if (!elements.title || !elements.artist || !elements.art) {
      return;
    }
    elements.title.textContent = reason === 'offline' ? 'Offline' : 'Silence!';
    elements.title.removeAttribute('href');
    elements.title.removeAttribute('target');
    elements.title.removeAttribute('rel');
    elements.title.setAttribute('aria-label', 'Not currently playing');
    elements.artist.textContent = 'Sam Foreman';
    elements.artist.setAttribute('href', 'https://samforeman.me');
    elements.artist.removeAttribute('target');
    elements.artist.removeAttribute('rel');
    elements.artist.setAttribute('aria-label', 'Visit Sam Foreman online');
    if (elements.art.dataset.placeholder) {
      elements.art.src = elements.art.dataset.placeholder;
    }
  };

  setFallback();

  const renderTrack = (track) => {
    if (!track) {
      setFallback();
      return;
    }

    const trackName = track.name ?? 'Unknown Track';
    const artistName = track.artist?.['#text'] ?? 'Unknown Artist';
    const trackUrl = track.url || '';

    elements.title.textContent = `🎶 ${trackName}`;
    elements.title.title = `${trackName} by ${artistName}`;
    elements.title.setAttribute('aria-label', `Now playing ${trackName} by ${artistName}`);

    if (trackUrl) {
      elements.title.href = trackUrl;
      elements.title.target = '_blank';
      elements.title.rel = 'noopener noreferrer';
    } else {
      elements.title.removeAttribute('href');
      elements.title.removeAttribute('target');
      elements.title.removeAttribute('rel');
    }

    elements.artist.textContent = `🗣️ ${artistName}`;
    elements.artist.title = `Artist: ${artistName}`;

    if (track.artist?.url) {
      elements.artist.href = track.artist.url;
      elements.artist.target = '_blank';
      elements.artist.rel = 'noopener noreferrer';
    } else {
      elements.artist.removeAttribute('href');
      elements.artist.removeAttribute('target');
      elements.artist.removeAttribute('rel');
    }

    const albumImages = Array.isArray(track.image) ? [...track.image] : [];
    const artSrc = albumImages.reverse().find((img) => img['#text'])?.['#text'];
    if (artSrc) {
      elements.art.src = artSrc;
      elements.art.removeAttribute('data-placeholder');
    } else {
      setFallback();
    }
  };

  const fetchTrack = async () => {
    const supportsAbort = typeof AbortController !== 'undefined';
    const controller = supportsAbort ? new AbortController() : null;
    const timeoutId = supportsAbort
      ? window.setTimeout(() => controller.abort(), lastFmConfig.requestTimeout)
      : null;
    try {
      const response = await fetch(buildUrl(), {
        headers: { 'Cache-Control': 'no-cache' },
        signal: controller?.signal,
      });
      if (!response.ok) {
        throw new Error(`Last.fm request failed: ${response.status}`);
      }
      const payload = await response.json();
      return payload?.recenttracks?.track?.[0];
    } finally {
      if (timeoutId) {
        window.clearTimeout(timeoutId);
      }
    }
  };

  const state = {
    isIntersecting: false,
    isLoading: false,
    timer: null,
  };

  const stopPolling = () => {
    if (state.timer) {
      window.clearTimeout(state.timer);
      state.timer = null;
    }
  };

  const scheduleNext = () => {
    if (state.timer) {
      window.clearTimeout(state.timer);
    }
    if (!shouldActivate()) {
      stopPolling();
      return;
    }
    state.timer = window.setTimeout(() => {
      if (document.hidden || !shouldActivate()) {
        scheduleNext();
        return;
      }
      updateTrack();
    }, lastFmConfig.refreshInterval);
  };

  const updateTrack = async () => {
    if (state.isLoading) {
      return;
    }

    if (prefersReducedData() || !navigator.onLine) {
      setFallback({ reason: navigator.onLine ? 'reduced-data' : 'offline' });
      stopPolling();
      return;
    }

    state.isLoading = true;
    try {
      const track = await fetchTrack();
      renderTrack(track);
    } catch (error) {
      if (error.name !== 'AbortError') {
        console.error('Unable to refresh Last.fm data.', error);
      }
      setFallback();
    } finally {
      state.isLoading = false;
      scheduleNext();
    }
  };

  const shouldActivate = () => {
    const detailsOpen = !hostDetails || hostDetails.open;
    return detailsOpen && state.isIntersecting && !prefersReducedData();
  };

  const activate = () => {
    if (!shouldActivate()) {
      return;
    }
    stopPolling();
    updateTrack();
  };

  const handleVisibility = () => {
    if (document.hidden) {
      stopPolling();
    } else if (shouldActivate()) {
      activate();
    }
  };

  document.addEventListener('visibilitychange', handleVisibility);
  window.addEventListener('offline', () => {
    setFallback({ reason: 'offline' });
    stopPolling();
  });
  window.addEventListener('online', () => {
    if (shouldActivate()) {
      activate();
    }
  });

  const connection = navigator.connection || navigator.mozConnection || navigator.webkitConnection;
  connection?.addEventListener?.('change', () => {
    if (shouldActivate()) {
      activate();
    } else {
      stopPolling();
    }
  });

  if (hostDetails) {
    hostDetails.addEventListener('toggle', () => {
      if (hostDetails.open) {
        if (state.isIntersecting) {
          activate();
        }
      } else {
        stopPolling();
      }
    });
  }

  if ('IntersectionObserver' in window) {
    const observer = new IntersectionObserver((entries) => {
      entries.forEach((entry) => {
        state.isIntersecting = entry.isIntersecting || entry.intersectionRatio > 0;
        if (state.isIntersecting) {
          activate();
        } else {
          stopPolling();
        }
      });
    }, { rootMargin: '120px 0px', threshold: 0.1 });
    observer.observe(root);
  } else {
    state.isIntersecting = true;
    activate();
  }
};

if (document.readyState === 'loading') {
  document.addEventListener('DOMContentLoaded', init, { once: true });
} else {
  init();
}
</script>
<div class="nowplayingcard" data-lastfm-root>
<div class="nowplayingcontainer-inner">
<img data-track-art width="120" height="120" loading="lazy" decoding="async" data-placeholder="./assets/avatar-100x100.webp" src="./assets/avatar-100x100.webp" alt="Album artwork placeholder" style="aspect-ratio: 1 / 1; object-fit: cover;">
<div class="trackInfo">
<a data-track-title></a>
<a data-track-artist></a>
</div>
</div>
</div>
```

